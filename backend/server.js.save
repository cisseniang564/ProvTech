// ====================================================================
// INTÃ‰GRATION BACKEND PROVTECH - SERVEUR PRINCIPAL MODIFIÃ‰
// Fichier: /Users/cisseniang/Documents/ProvTech/backend/server.js
// ====================================================================

const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');
const mysql = require('mysql2/promise');
require('dotenv').config();

// Import du middleware de compatibilitÃ©
const { 
  compatibilityAuth, 
  requirePermission, 
  migrationRouter,
  initializeDatabase 
} = require('./middleware/CompatibilityAuth');

// Import du contrÃ´leur sÃ©curisÃ©
const secureAuthRoutes = require('./routes/secure/auth');

const app = express();
const PORT = process.env.PORT || 3001;

// ============ CONFIGURATION SÃ‰CURITÃ‰ ============
app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      scriptSrc: ["'self'"],
      imgSrc: ["'self'", "data:", "https:"],
    },
  },
}));

app.use(cors({
  origin: process.env.FRONTEND_URL || ['http://localhost:3000', 'http://localhost:5173'],
  credentials: true
}));

app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true }));

// Rate limiting global
const globalLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 1000, // 1000 requÃªtes par IP par fenÃªtre
  message: { error: 'Trop de requÃªtes. RÃ©essayez plus tard.' }
});

app.use(globalLimiter);

// ============ INITIALISATION BASE DE DONNÃ‰ES ============
let db = null;

async function initApp() {
  try {
    // Initialiser la connexion DB
    db = await initializeDatabase();
    console.log('âœ… Connexion base de donnÃ©es Ã©tablie');
    
    // Test de la structure
    const [tables] = await db.execute(`
      SELECT TABLE_NAME 
      FROM INFORMATION_SCHEMA.TABLES 
      WHERE TABLE_SCHEMA = ? AND TABLE_NAME IN ('users', 'audit_logs', 'user_sessions')
    `, [process.env.DB_NAME || 'provtech']);
    
    console.log('ðŸ“‹ Tables disponibles:', tables.map(t => t.TABLE_NAME));
    
  } catch (error) {
    console.error('âŒ Erreur initialisation DB:', error);
    process.exit(1);
  }
}

// ============ ROUTES PUBLIQUES ============
app.get('/api/health', (req, res) => {
  res.json({
    status: 'OK',
    timestamp: new Date(),
    uptime: process.uptime(),
    version: '1.0.0-hybrid',
    authModes: ['legacy', 'secure'],
    environment: process.env.NODE_ENV || 'development'
  });
});

// ============ ROUTES SÃ‰CURISÃ‰ES (NOUVELLES) ============
// SystÃ¨me d'authentification sÃ©curisÃ© avec 2FA
app.use('/api/auth', secureAuthRoutes);

// Routes de migration 
app.use('/api/migration', migrationRouter);

// ============ ROUTES LEGACY (VOS ROUTES ACTUELLES) ============
// Gardez toutes vos routes existantes ici
// Exemple de structure recommandÃ©e :

// Routes d'authentification legacy (conservÃ©es)
// app.use('/api/legacy/auth', require('./routes/legacy/auth'));

// Routes triangles (avec middleware hybride)
// app.use('/api/triangles', compatibilityAuth, require('./routes/triangles'));

// Routes calculs (avec middleware hybride) 
// app.use('/api/calculations', compatibilityAuth, require('./routes/calculations'));

// Routes rapports (avec middleware hybride)
// app.use('/api/reports', compatibilityAuth, require('./routes/reports'));

// ============ ROUTES ADMINISTRATEUR SÃ‰CURISÃ‰ES ============
app.use('/api/admin', 
  compatibilityAuth, 
  requirePermission('admin:read'),
  require('./routes/admin')
);

// Gestion des utilisateurs (Admin uniquement)
app.get('/api/users',
  compatibilityAuth,
  requirePermission('users:read'),
  async (req, res) => {
    try {
      const [rows] = await db.execute(`
        SELECT 
          id, email, firstName, lastName, role, department, 
          mfa_enabled, last_login, created_at, restrictions,
          migrated_to_secure, legacy_auth_enabled
        FROM users 
        WHERE isActive = true
        ORDER BY created_at DESC
      `);

      res.json(rows);
    } catch (error) {
      console.error('Erreur lecture utilisateurs:', error);
      res.status(500).json({ error: 'Erreur serveur' });
    }
  }
);

// CrÃ©ation d'utilisateurs (Admin uniquement)
app.post('/api/users',
  compatibilityAuth,
  requirePermission('users:write'),
  async (req, res) => {
    try {
      const { email, firstName, lastName, role, department, restrictions } = req.body;
      
      if (!email || !firstName || !lastName) {
        return res.status(400).json({ error: 'Champs obligatoires manquants' });
      }

      // VÃ©rifier email unique
      const [existing] = await db.execute('SELECT id FROM users WHERE email = ?', [email]);
      if (existing.length > 0) {
        return res.status(409).json({ error: 'Email dÃ©jÃ  utilisÃ©' });
      }

      // GÃ©nÃ©rer mot de passe temporaire
      const bcrypt = require('bcrypt');
      const tempPassword = Math.random().toString(36).slice(-8);
      const hashedPassword = await bcrypt.hash(tempPassword, 12);

      const userId = require('crypto').randomUUID();

      await db.execute(`
        INSERT INTO users (
          id, email, password, firstName, lastName, role, department,
          restrictions, isActive, must_change_password, created_at
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, true, true, NOW())
      `, [
        userId, email.toLowerCase(), hashedPassword, firstName, lastName,
        role || 'ACTUAIRE_JUNIOR', department, JSON.stringify(restrictions || {})
      ]);

      console.log(`Utilisateur crÃ©Ã©: ${email} - Mot de passe temporaire: ${tempPassword}`);

      res.status(201).json({
        message: 'Utilisateur crÃ©Ã© avec succÃ¨s',
        user: { id: userId, email, firstName, lastName, role, department },
        temporaryPassword: tempPassword
      });

    } catch (error) {
      console.error('Erreur crÃ©ation utilisateur:', error);
      res.status(500).json({ error: 'Erreur serveur' });
    }
  }
);

// ============ ROUTES AUDIT SÃ‰CURISÃ‰ES ============
app.get('/api/audit',
  compatibilityAuth,
  requirePermission('audit:read'),
  async (req, res) => {
    try {
      const { limit = 100, offset = 0, userId, eventType, startDate, endDate } = req.query;
      
      let whereClause = 'WHERE 1=1';
      const params = [];
      
      if (userId) {
        whereClause += ' AND user_id = ?';
        params.push(userId);
      }
      if (eventType) {
        whereClause += ' AND event_type = ?';
        params.push(eventType);
      }
      if (startDate) {
        whereClause += ' AND timestamp >= ?';
        params.push(startDate);
      }
      if (endDate) {
        whereClause += ' AND timestamp <= ?';
        params.push(endDate);
      }

      const [logs] = await db.execute(`
        SELECT * FROM audit_logs 
        ${whereClause}
        ORDER BY timestamp DESC 
        LIMIT ? OFFSET ?
      `, [...params, parseInt(limit), parseInt(offset)]);

      const [countResult] = await db.execute(`
        SELECT COUNT(*) as total FROM audit_logs ${whereClause}
      `, params);

      res.json({
        logs,
        total: countResult[0].total,
        limit: parseInt(limit),
        offset: parseInt(offset)
      });

    } catch (error) {
      console.error('Erreur lecture audit:', error);
      res.status(500).json({ error: 'Erreur serveur' });
    }
  }
);

// ============ ROUTES DE COMPATIBILITÃ‰ ============
// Route pour vÃ©rifier l'auth (utilisÃ©e par le frontend)
app.get('/api/auth/verify',
  compatibilityAuth,
  (req, res) => {
    res.json({
      user: req.user,
      authMode: req.authMode,
      migrationAvailable: req.authMode === 'legacy' && !req.user.migratedToSecure
    });
  }
);

// ============ MIDDLEWARE D'ERREUR ============
app.use((error, req, res, next) => {
  console.error('Erreur serveur:', error);
  
  if (error.type === 'entity.too.large') {
    return res.status(413).json({ error: 'Fichier trop volumineux' });
  }

  res.status(500).json({ 
    error: 'Erreur interne du serveur',
    timestamp: new Date().toISOString()
  });
});

// ============ ROUTE 404 ============
app.use('*', (req, res) => {
  res.status(404).json({ 
    error: 'Route non trouvÃ©e',
    path: req.originalUrl 
  });
});

// ============ DÃ‰MARRAGE SERVEUR ============
const startServer = async () => {
  try {
    await initApp();
    
    app.listen(PORT, () => {
      console.log(`
ðŸš€ ProvTech Backend Hybride dÃ©marrÃ©
ðŸ“ Port: ${PORT}
ðŸ”„ Mode: Hybride (Legacy + SÃ©curisÃ©)
ðŸ—„ï¸  Base: ${process.env.DB_NAME || 'provtech'}
ðŸ” Auth: JWT + 2FA + Legacy
ðŸ“Š Environment: ${process.env.NODE_ENV || 'development'}

ðŸ“‹ Routes disponibles:
   â€¢ /api/auth/* (SystÃ¨me sÃ©curisÃ©)
   â€¢ /api/migration/* (Migration utilisateurs)  
   â€¢ /api/users (Gestion utilisateurs)
   â€¢ /api/audit (Logs sÃ©curisÃ©s)
   â€¢ /api/health (SantÃ© du serveur)

ðŸŽ¯ Votre ProvTech existant reste fonctionnel !
      `);
    });
    
  } catch (error) {
    console.error('âŒ Erreur dÃ©marrage serveur:', error);
    process.exit(1);
  }
};

// Gestion propre de l'arrÃªt
process.on('SIGTERM', async () => {
  console.log('ðŸ›‘ ArrÃªt du serveur...');
  if (db) {
    await db.end();
  }
  process.exit(0);
});

process.on('SIGINT', async () => {
  console.log('ðŸ›‘ ArrÃªt du serveur (Ctrl+C)...');
  if (db) {
    await db.end();
  }
  process.exit(0);
});

startServer();

module.exports = a
